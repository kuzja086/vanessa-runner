///////////////////////////////////////////////////////////////////////////////
//
// Служебный модуль с реализацией работы команд
//
// Структура модуля реализована в соответствии с рекомендациями
// oscript-app-template (C) EvilBeaver
//
///////////////////////////////////////////////////////////////////////////////

#Использовать logos
#Использовать v8runner
#Использовать fs
#Использовать tempfiles

Перем Лог;
Перем КорневойПутьПроекта;

Процедура НастроитьКоманду(Знач Команда, Знач Парсер) Экспорт
		ТекстОписания =
		"     Обновление конфигурации при разработке в ЕДТ.
		|";

	ОписаниеКоманды = Парсер.ОписаниеКоманды(ИмяКоманды, ТекстОписания);

	Парсер.ДобавитьИменованныйПараметрКоманды(ОписаниеКоманды, "--src", 
		СтрШаблон("Путь к папке исходников
		|
		|Схема работы:
		|		Указываем путь к исходникам с конфигурацией,
		|		Указываем в каком формате исходники хранятся в гите,
		|		При загрузке в каталоге исходников (--src) ищется файл 
		| 		%1 (необходимо добавить в .gitignore).
		| 		Если файл найден, получается дифф изменений относительно 
		| 		последнего загруженного коммиту к HEAD.
		| 		Если файл не найден, происходит полная загрузка.
		| 		После загрузки создается\обновляется файл %1
		|		обновляем базу.", ИмяФайлаПредыдущегоГитКоммита()));

	Парсер.ДобавитьПараметрФлагКоманды(ОписаниеКоманды, "--src-edt", "Исходники в формате EDT");
	
	Парсер.ДобавитьПараметрФлагКоманды(ОписаниеКоманды, "--storage-lock", 
		"Захват объектов в хранилище при инкрементальной загрузке");
	Парсер.ДобавитьИменованныйПараметрКоманды(ОписаниеКоманды, "--storage-name", "Строка подключения к хранилищу");
	Парсер.ДобавитьИменованныйПараметрКоманды(ОписаниеКоманды, "--storage-user", "Пользователь хранилища");
	Парсер.ДобавитьИменованныйПараметрКоманды(ОписаниеКоманды, "--storage-pwd", "Пароль");
	Парсер.ДобавитьПараметрФлагКоманды(ОписаниеКоманды, "--storageCommit", "Поместить в хранилище");

	Парсер.ДобавитьКоманду(ОписаниеКоманды);

КонецПроцедуры // НастроитьКоманду

// Выполняет логику команды
// 
// Параметры:
//   ПараметрыКоманды - Соответствие - Соответствие ключей командной строки и их значений
//   Приложение - Модуль - Модуль менеджера приложения
//
Функция ВыполнитьКоманду(Знач ПараметрыКоманды, Знач Приложение) Экспорт
	
	Лог = ДополнительныеПараметры.Лог;
	КорневойПутьПроекта = ПараметрыСистемы.КорневойПутьПроекта;

	ДанныеПодключения = ПараметрыКоманды["ДанныеПодключения"];

	ПараметрыХранилища = Новый Структура;
	ПараметрыХранилища.Вставить("ЗахватитьВХранилище", ПараметрыКоманды["--storage-lock"]);
	ПараметрыХранилища.Вставить("СтрокаПодключения", ПараметрыКоманды["--storage-name"]);
	ПараметрыХранилища.Вставить("Пользователь", ПараметрыКоманды["--storage-user"]);
	ПараметрыХранилища.Вставить("Пароль", ПараметрыКоманды["--storage-pwd"]);
	ПараметрыХранилища.Вставить("ПомещатьВХранилище", ПараметрыКоманды["--storageCommit"]);

	ПараметрыИсходников = Новый Структура;
	ПараметрыИсходников.Вставить("ПутьКИсходникам", ПараметрыКоманды["--src"]);
	ПараметрыИсходников.Вставить("ИсходникиВФорматеEDT", ПараметрыКоманды["--src-edt"]);

	ОбновитьБазуДанных(ДанныеПодключения, ПараметрыХранилища, ПараметрыИсходников);

	// При успешном выполнении возвращает код успеха
	Возврат Приложение.РезультатыКоманд().Успех;
	
КонецФункции // ВыполнитьКоманду

Функция ИмяФайлаПредыдущегоГитКоммита()
	Возврат "lastUploadedCommit.txt";
КонецФункции


Процедура ОбновитьБазуДанных(Знач ДанныеПодключения, Знач ПараметрыХранилища, Знач ПараметрыИсходников)

	// Перем БазуСоздавали;
	// БазуСоздавали = Ложь;
	ТекущаяПроцедура = "Запускаем обновление";

	СтрокаПодключения = ДанныеПодключения.ПутьБазы;
	Пользователь = ДанныеПодключения.Пользователь;
	Пароль = ДанныеПодключения.Пароль;

	ЗахватитьВХранилище = ПараметрыХранилища.ЗахватитьВХранилище;
	СтрокаПодключенияХранилище = ПараметрыХранилища.СтрокаПодключения;
	ПользовательХранилища = ПараметрыХранилища.Пользователь;
	ПарольХранилища = ПараметрыХранилища.Пароль;
	ПомещатьВХранилище = ПараметрыХранилища.ПомещатьВХранилище;

	ПутьИсходников = ПараметрыИсходников.ПутьКИсходникам;
	ИсходникиВФорматеEDT = ПараметрыИсходников.ИсходникиВФорматеEDT;

	Логирование.ПолучитьЛог("oscript.lib.v8runner").УстановитьУровень(Лог.Уровень());

	Если ПустаяСтрока(СтрокаПодключения) Тогда
		КаталогБазы = ОбъединитьПути(КорневойПутьПроекта, ?(РежимРазработчика = Истина, "./build/ibservice", "./build/ib"));
		СтрокаПодключения = "/F""" + КаталогБазы + """";
	КонецЕсли;

	Лог.Отладка("ИнициализироватьБазуДанных СтрокаПодключения:" + СтрокаПодключения);

	Если Лев(СтрокаПодключения, 2) = "/F" Тогда
		КаталогБазы = ОбщиеМетоды.УбратьКавычкиВокругПути(Сред(СтрокаПодключения, 3, СтрДлина(СтрокаПодключения) - 2));
		ФайлБазы = Новый Файл(КаталогБазы);
		Ожидаем.Что(ФайлБазы.Существует(), ТекущаяПроцедура + " папка с базой существует").ЭтоИстина();
	КонецЕсли;

	МенеджерКонфигуратора = Новый МенеджерКонфигуратора;
	// При первичной инициализации опускаем указание пользователя и пароля, т.к. их еще нет.
	МенеджерКонфигуратора.Инициализация(
		СтрокаПодключения, "", "",
		ВерсияПлатформы, КлючРазрешенияЗапуска,
		КодЯзыка
		);

	Конфигуратор = МенеджерКонфигуратора.УправлениеКонфигуратором();
	Конфигуратор.УстановитьИмяФайлаСообщенийПлатформы(ВременныеФайлы.НовоеИмяФайла("log"));
	Конфигуратор.УстановитьКонтекст(СтрокаПодключения, Пользователь, Пароль);

	// по дифу получить соответсиве дифа файлов едт, файлам конфигуратора
	Лог.Информация("Получаем список файлов для загрузки");
	Если ИсходникиВФорматеEDT Тогда
		ПутьИсходников = КонвертироватьИсходникиИзЕДТ(ПутьИсходников);
	КонецЕсли;

	ДанныеДляЧастичнойЗагрузки = ДанныеДляЧастичнойЗагрузки(ПутьИсходников);

	Если ЗахватитьВХранилище Тогда
		Лог.Информация("Захват объектов в хранилище");
		МенеджерКонфигуратора.ЗахватитьОбъектыВХранилище(
			СтрокаПодключенияХранилище, ПользовательХранилища, ПарольХранилища,
			ДанныеДляЧастичнойЗагрузки.СписокОбъектовХранилища);	
	КонецЕсли;

	Лог.Информация("Запускаю загрузку конфигурации из исходников");
	
	Если Не ПустаяСтрока(СписокФайлов) Тогда

		Лог.Информация(
			"Будет выполнена инкрементальная загрузка
			|Измененные файлы: 
			|%1", 
			СтрСоединить(СтрРазделить(СписокФайлов, ";"), Символы.ПС)
		);

	КонецЕсли;

	ПутьИсходников = Новый Файл(ОбъединитьПути(КорневойПутьПроекта, ПутьИсходников)).ПолноеИмя;

	МенеджерКонфигуратора.СобратьИзИсходниковТекущуюКонфигурацию(
		ПутьИсходников, ДанныеДляЧастичнойЗагрузки.СтрокаИзмененныхФайлов);
	
	ЗаписатьХэшПоследнегоЗагруженногоКоммита(ПутьИсходников);

	МенеджерКонфигуратора.Деструктор();

КонецПроцедуры // ОбновитьБазуДанных

Функция КонвертироватьИсходникиИзЕДТ(ПутьИсходников)
	ПутьКонвертированыхИсходников = "";
	Возврат ПутьКонвертированыхИсходников;
КонецФункции

Функция ДанныеДляЧастичнойЗагрузки(ПутьИсходников)
	ДанныеДляЧастичнойЗагрузки = Новый Структура();
	ДанныеДляЧастичнойЗагрузки("СтрокаИзмененныхФайлов", "");

	Хэш = ПолучитьХэшПоследнегоЗагруженногоКоммита(ПутьИсходников);

	Если ПустаяСтрока(Хэш) Тогда
		ВызватьИсключение "Нет хеша последнего загруженного коммита"
	КонецЕсли;

	ТекущийКаталог = ТекущийКаталог();

	КоманднаяСтрока = СтрШаблон("git diff --name-only %1 HEAD", Хэш);

	Процесс = СоздатьПроцесс(КоманднаяСтрока, ТекущийКаталог, Истина, , КодировкаТекста.UTF8);
	Процесс.Запустить();

	Процесс.ОжидатьЗавершения();

	СтрокаИзмененныхФайлов = "";
	Пока Процесс.ПотокВывода.ЕстьДанные Цикл

		СтрокаВывода = Процесс.ПотокВывода.ПрочитатьСтроку();
		Если СтрНачинаетсяС(СтрокаВывода, СтрЗаменить(ПутьИсходников, "./", ""))
			И Не ФайлВСпискеИсключений(СтрокаВывода) Тогда

			СтрокаВывода = СкорректироватьПутьКИзменениюФормы(СтрокаВывода);

			ТекущаяСтрока = ОбъединитьПути(ТекущийКаталог, СтрокаВывода);
			ТекущаяСтрока = СтрЗаменить(ТекущаяСтрока, "/", ПолучитьРазделительПути());

			Если СтрНайти(СтрокаИзмененныхФайлов, ТекущаяСтрока) = 0 
				И Новый Файл(ТекущаяСтрока).Существует() Тогда

				СтрокаИзмененныхФайлов = СтрокаИзмененныхФайлов + ТекущаяСтрока + ";";
			
			КонецЕсли;

		КонецЕсли;

	КонецЦикла;

	Если ЗначениеЗаполнено(СтрокаИзмененныхФайлов) Тогда
		СтрокаИзмененныхФайлов = Лев(СтрокаИзмененныхФайлов, СтрДлина(СтрокаИзмененныхФайлов) - 1);
	КонецЕсли;

	ДанныеДляЧастичнойЗагрузки("СтрокаИзмененныхФайлов", СтрокаИзмененныхФайлов);

	Возврат ДанныеДляЧастичнойЗагрузки;
КонецФункции

Функция ПолучитьХэшПоследнегоЗагруженногоКоммита(Знач ПутьИсходников) 

	ИмяФайла = ФайлПредыдущегоГитКоммита(ПутьИсходников).ПолноеИмя;

	Если Не ФС.ФайлСуществует(ИмяФайла) Тогда
		Возврат "";
	КонецЕсли;

	ЧтениеТекста = Новый ЧтениеТекста(ИмяФайла, КодировкаТекста.UTF8NoBOM);
	Хэш = ЧтениеТекста.Прочитать();
	ЧтениеТекста.Закрыть();

	Возврат СокрЛП(Хэш);

КонецФункции

Процедура ЗаписатьХэшПоследнегоЗагруженногоКоммита(Знач ПутьИсходников)

	ИмяФайла = ФайлПредыдущегоГитКоммита(ПутьИсходников).ПолноеИмя;

	ТекущийКаталог = ТекущийКаталог();

	КоманднаяСтрока = "git rev-parse --short HEAD";

	Процесс = СоздатьПроцесс(КоманднаяСтрока, ТекущийКаталог, Истина, , КодировкаТекста.UTF8);
	Процесс.Запустить();

	Процесс.ОжидатьЗавершения();

	Если Процесс.ПотокВывода.ЕстьДанные Тогда

		Хэш = Процесс.ПотокВывода.ПрочитатьСтроку();

		ЗаписьТекста = Новый ЗаписьТекста(ИмяФайла, КодировкаТекста.UTF8NoBOM);
		ЗаписьТекста.Записать(Хэш);
		ЗаписьТекста.Закрыть();

	КонецЕсли;

КонецПроцедуры

Функция СкорректироватьПутьКИзменениюФормы(СтрокаИзмененныхФайлов)
	
	Паттерн = "(.*Forms\/.*)\/Ext.*";

	РегулярноеВыражение = Новый РегулярноеВыражение(Паттерн);

	КоллекцияСовпаденийРегулярногоВыражения = РегулярноеВыражение.НайтиСовпадения(СтрокаИзмененныхФайлов);

	Если КоллекцияСовпаденийРегулярногоВыражения.Количество() = 1 
		И КоллекцияСовпаденийРегулярногоВыражения[0].Группы.Количество() = 2 Тогда

		Возврат РегулярноеВыражение.Заменить(СтрокаИзмененныхФайлов, "$1.xml");

	КонецЕсли;

	Возврат СтрокаИзмененныхФайлов;
КонецФункции

Функция ФайлВСпискеИсключений(ПутьКФайлу)

	Возврат СтрЗаканчиваетсяНа(ПутьКФайлу, "ConfigDumpInfo.xml")
		Или СтрЗаканчиваетсяНа(ПутьКФайлу, "AUTHORS")
		Или СтрЗаканчиваетсяНа(ПутьКФайлу, "VERSION");
		
КонецФункции

Функция ФайлПредыдущегоГитКоммита(Знач ПутьИсходников)
	
	Возврат Новый Файл(ОбъединитьПути(КорневойПутьПроекта, ПутьИсходников, ИмяФайлаПредыдущегоГитКоммита()));
	
КонецФункции